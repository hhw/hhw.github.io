<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="Change is the ONLY constant.">
  <meta name="keyword" content="undefined">
  <title>
    
      Go语言的修饰器编程 | 如是我曰（IMHO）
    
  </title>
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/css/plugins/gitment.css">
  <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>
  <script src="/js/qrious.js"></script>
  <script src="/js/gitment.js"></script>
</head>
  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>如是我曰（IMHO）</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/project/" class="item-link">Projects</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/project/" class="menu-link">Projects</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>Go语言的修饰器编程</h2>
  <p class="post-date">2017-06-01</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body">
  <article class="post-article">
    <section class="markdown-content"><p><img src="http://coolshell.cn//wp-content/uploads/2017/06/go-hardhat.png" alt="">之前写过一篇《<a href="http://coolshell.cn/articles/11265.html" target="_blank" rel="external">Python修饰器的函数式编程</a>》，这种模式很容易的可以把一些函数装配到另外一些函数上，可以让你的代码更为的简单，也可以让一些“小功能型”的代码复用性更高，让代码中的函数可以像乐高玩具那样自由地拼装。所以，一直以来，我对修饰器decoration这种编程模式情有独钟，这里写一篇Go语言相关的文章。</p>
<p>看过<a href="http://coolshell.cn/articles/11265.html" target="_blank" rel="external">Python修饰器</a>那篇文章的同学，一定知道这是一种函数式编程的玩法——用一个高阶函数来包装一下。多唠叨一句，关于函数式编程，可以参看我之前写过一篇文章《<a href="http://coolshell.cn/articles/10822.html" target="_blank" rel="external">函数式编程</a>》，这篇文章主要是，想通过从过程式编程的思维方式过渡到函数式编程的思维方式，从而带动更多的人玩函数式编程，所以，如果你想了解一下函数式编程，那么可以移步先阅读一下。所以，Go语言的修饰器编程模式，其实也就是函数式编程的模式。</p>
<p>不过，要提醒注意的是，Go 语言的“糖”不多，而且又是强类型的静态无虚拟机的语言，所以，无法做到像 Java 和 Python 那样的优雅的修饰器的代码。当然，也许是我才才疏学浅，如果你知道有更多的写法，请你一定告诉我。先谢过了。</p>
<p><span id="more-17929"></span></p>
<h4 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h4><p>我们先来看一个示例：</p>
<pre class="brush: cpp; title: ; notranslate">package main

import &quot;fmt&quot;

func decorator(f func(s string)) func(s string) {

        return func(s string) {
                fmt.Println(&quot;Started&quot;)
                f(s)
                fmt.Println(&quot;Done&quot;)
        }
}

func Hello(s string) {
        fmt.Println(s)
}

func main() {
        decorator(Hello)(&quot;Hello, World!&quot;)
}</pre>

<p>我们可以看到，我们动用了一个高阶函数 <code>decorator()</code>，在调用的时候，先把 <code>Hello()</code> 函数传进去，然后其返回一个匿名函数，这个匿名函数中除了运行了自己的代码，也调用了被传入的 <code>Hello()</code> 函数。</p>
<p>这个玩法和 Python 的异曲同工，只不过，有些遗憾的是，Go 并不支持像 Python 那样的 <code>@decorator</code> 语法糖。所以，在调用上有些难看。当然，如果你要想让代码容易读一些，你可以这样：</p>
<pre class="brush: cpp; title: ; notranslate">hello := decorator(Hello)
hello(&quot;Hello&quot;)</pre>

<p>我们再来看一个和计算运行时间的例子：</p>
<pre class="brush: cpp; highlight: [16,17,18,19,20,21,22,23,24,25,26]; title: ; notranslate">package main

import (
  &quot;fmt&quot;
  &quot;reflect&quot;
  &quot;runtime&quot;
  &quot;time&quot;
)

type SumFunc func(int64, int64) int64

func getFunctionName(i interface{}) string {
  return runtime.FuncForPC(reflect.ValueOf(i).Pointer()).Name()
}

func timedSumFunc(f SumFunc) SumFunc {
  return func(start, end int64) int64 {

    defer func(t time.Time) {
      fmt.Printf(&quot;--- Time Elapsed (%s): %v ---\n&quot;, 
          getFunctionName(f), time.Since(t))
    }(time.Now())

    return f(start, end)
  }
}

func Sum1(start, end int64) int64 {
  var sum int64
  sum = 0
  if start &gt; end {
    start, end = end, start
  }
  for i := start; i &lt;= end; i++ {
    sum += i
  }
  return sum
}

func Sum2(start, end int64) int64 {
  if start &gt; end {
    start, end = end, start
  }
  return (end - start + 1) * (end + start) / 2
}

func main() {

  sum1 := timedSumFunc(Sum1)
  sum2 := timedSumFunc(Sum2)

  fmt.Printf(&quot;%d, %d\n&quot;, sum1(-10000, 10000000), sum2(-10000, 10000000))
}</pre>

<p>关于上面的代码，有几个事说明一下：</p>
<p>1）有两个 Sum 函数，<code>Sum1()</code> 函数就是简单的做个循环，<code>Sum2()</code> 函数动用了数据公式。（注意：start 和 end 有可能有负数的情况）</p>
<p>2）代码中使用了 Go 语言的反射机器来获取函数名。</p>
<p>3）修饰器函数是 <code>timedSumFunc()</code></p>
<p>运行后输出：</p>
<pre class="brush: bash; title: ; notranslate">
$ go run time.sum.go
--- Time Elapsed (main.Sum1): 3.557469ms ---
--- Time Elapsed (main.Sum2): 291ns ---
49999954995000, 49999954995000
</pre>

<h4 id="HTTP-相关的一个示例"><a href="#HTTP-相关的一个示例" class="headerlink" title="HTTP 相关的一个示例"></a>HTTP 相关的一个示例</h4><p>我们再来看一个处理 HTTP 请求的相关的例子。</p>
<p>先看一个简单的 HTTP Server 的代码。</p>
<pre class="brush: cpp; highlight: [10,11,12,13,14,15,16,24]; title: ; notranslate">
package main

import (
        &quot;fmt&quot;
        &quot;log&quot;
        &quot;net/http&quot;
        &quot;strings&quot;
)

func WithServerHeader(h http.HandlerFunc) http.HandlerFunc {
        return func(w http.ResponseWriter, r *http.Request) {
                log.Println(&quot;---&gt;WithServerHeader()&quot;)
                w.Header().Set(&quot;Server&quot;, &quot;HelloServer v0.0.1&quot;)
                h(w, r)
        }
}

func hello(w http.ResponseWriter, r *http.Request) {
        log.Printf(&quot;Recieved Request %s from %s\n&quot;, r.URL.Path, r.RemoteAddr)
        fmt.Fprintf(w, &quot;Hello, World! &quot;+r.URL.Path)
}

func main() {
        http.HandleFunc(&quot;/v1/hello&quot;, WithServerHeader(hello))
        err := http.ListenAndServe(&quot;:8080&quot;, nil)
        if err != nil {
                log.Fatal(&quot;ListenAndServe: &quot;, err)
        }
}</pre>

<p>上面代码中使用到了修饰模式，<code>WithServerHeader()</code> 函数就是一个 Decorator，其传入一个 <code>http.HandlerFunc</code>，然后返回一个改写的版本。上面的例子还是比较简单，用 <code>WithServerHeader()</code> 就可以加入一个 Response 的 Header。</p>
<p>于是，这样的函数我们可以写出好些个。如下所示，有写 HTTP 响应头的，有写认证 Cookie 的，有检查认证Cookie的，有打日志的…… </p>
<pre class="brush: cpp; highlight: [60,61,62]; title: ; notranslate">package main

import (
        &quot;fmt&quot;
        &quot;log&quot;
        &quot;net/http&quot;
        &quot;strings&quot;
)

func WithServerHeader(h http.HandlerFunc) http.HandlerFunc {
        return func(w http.ResponseWriter, r *http.Request) {
                log.Println(&quot;---&gt;WithServerHeader()&quot;)
                w.Header().Set(&quot;Server&quot;, &quot;HelloServer v0.0.1&quot;)
                h(w, r)
        }
}

func WithAuthCookie(h http.HandlerFunc) http.HandlerFunc {
        return func(w http.ResponseWriter, r *http.Request) {
                log.Println(&quot;---&gt;WithAuthCookie()&quot;)
                cookie := &amp;http.Cookie{Name: &quot;Auth&quot;, Value: &quot;Pass&quot;, Path: &quot;/&quot;}
                http.SetCookie(w, cookie)
                h(w, r)
        }
}

func WithBasicAuth(h http.HandlerFunc) http.HandlerFunc {
        return func(w http.ResponseWriter, r *http.Request) {
                log.Println(&quot;---&gt;WithBasicAuth()&quot;)
                cookie, err := r.Cookie(&quot;Auth&quot;)
                if err != nil || cookie.Value != &quot;Pass&quot; {
                        w.WriteHeader(http.StatusForbidden)
                        return
                }
                h(w, r)
        }
}

func WithDebugLog(h http.HandlerFunc) http.HandlerFunc {
        return func(w http.ResponseWriter, r *http.Request) {
                log.Println(&quot;---&gt;WithDebugLog&quot;)
                r.ParseForm()
                log.Println(r.Form)
                log.Println(&quot;path&quot;, r.URL.Path)
                log.Println(&quot;scheme&quot;, r.URL.Scheme)
                log.Println(r.Form[&quot;url_long&quot;])
                for k, v := range r.Form {
                        log.Println(&quot;key:&quot;, k)
                        log.Println(&quot;val:&quot;, strings.Join(v, &quot;&quot;))
                }
                h(w, r)
        }
}
func hello(w http.ResponseWriter, r *http.Request) {
        log.Printf(&quot;Recieved Request %s from %s\n&quot;, r.URL.Path, r.RemoteAddr)
        fmt.Fprintf(w, &quot;Hello, World! &quot;+r.URL.Path)
}

func main() {
        http.HandleFunc(&quot;/v1/hello&quot;, WithServerHeader(WithAuthCookie(hello)))
        http.HandleFunc(&quot;/v2/hello&quot;, WithServerHeader(WithBasicAuth(hello)))
        http.HandleFunc(&quot;/v3/hello&quot;, WithServerHeader(WithBasicAuth(WithDebugLog(hello))))
        err := http.ListenAndServe(&quot;:8080&quot;, nil)
        if err != nil {
                log.Fatal(&quot;ListenAndServe: &quot;, err)
        }
}</pre>

<h4 id="多个修饰器的-Pipeline"><a href="#多个修饰器的-Pipeline" class="headerlink" title="多个修饰器的 Pipeline"></a>多个修饰器的 Pipeline</h4><p>在使用上，需要对函数一层层的套起来，看上去好像不是很好看，如果需要 decorator 比较多的话，代码会比较难看了。嗯，我们可以重构一下。</p>
<p>重构时，我们需要先写一个工具函数——用来遍历并调用各个 decorator：</p>
<pre class="brush: cpp; title: ; notranslate">type HttpHandlerDecorator func(http.HandlerFunc) http.HandlerFunc

func Handler(h http.HandlerFunc, decors ...HttpHandlerDecorator) http.HandlerFunc {
        for i := range decors {
                d := decors[len(decors)-1-i] // iterate in reverse
                h = d(h)
        }
        return h
}</pre>

<p>然后，我们就可以像下面这样使用了。</p>
<pre class="brush: cpp; title: ; notranslate">http.HandleFunc(&quot;/v4/hello&quot;, Handler(hello,
                WithServerHeader, WithBasicAuth, WithDebugLog))</pre>

<p>这样的代码是不是更易读了一些？pipeline 的功能也就出来了。</p>
<h4 id="泛型的修饰器"><a href="#泛型的修饰器" class="headerlink" title="泛型的修饰器"></a>泛型的修饰器</h4><p>不过，对于 Go 的修饰器模式，还有一个小问题 —— 好像无法做到泛型，就像上面那个计算时间的函数一样，其代码耦合了需要被修饰的函数的接口类型，无法做到非常通用，如果这个事解决不了，那么，这个修饰器模式还是有点不好用的。</p>
<p>因为 Go 语言不像 Python 和 Java，Python是动态语言，而 Java 有语言虚拟机，所以他们可以干好些比较变态的事，然而 Go 语言是一个静态的语言，这意味着其类型需要在编译时就要搞定，否则无法编译。不过，Go 语言支持的最大的泛型是 <code>interface{}</code> 还有比较简单的 reflection 机制，在上面做做文章，应该还是可以搞定的。</p>
<p>废话不说，下面是我用 reflection 机制写的一个比较通用的修饰器（为了便于阅读，我删除了出错判断代码）</p>
<pre class="brush: cpp; highlight: [7,10]; title: ; notranslate">func Decorator(decoPtr, fn interface{}) (err error) {
        var decoratedFunc, targetFunc reflect.Value

        decoratedFunc = reflect.ValueOf(decoPtr).Elem()
        targetFunc = reflect.ValueOf(fn)

        v := reflect.MakeFunc(targetFunc.Type(),
                func(in []reflect.Value) (out []reflect.Value) {
                        fmt.Println(&quot;before&quot;)
                        out = targetFunc.Call(in)
                        fmt.Println(&quot;after&quot;)
                        return
                })

        decoratedFunc.Set(v)
        return
}</pre>

<p>上面的代码动用了 <code>reflect.MakeFunc()</code> 函数制出了一个新的函数其中的 <code>targetFunc.Call(in)</code> 调用了被修饰的函数。关于 Go 语言的反射机制，推荐官方文章 —— 《<a href="https://blog.golang.org/laws-of-reflection" target="_blank" rel="external">The Laws of Reflection</a>》，在这里我不多说了。</p>
<p>上面这个 <code>Decorator()</code> 需要两个参数，</p>
<ul>
<li>第一个是出参 <code>decoPtr</code> ，就是完成修饰后的函数*   第二个是入参 <code>fn</code> ，就是需要修饰的函数</li>
</ul>
<p>这样写是不是有些二？的确是的。不过，这是我个人在 Go 语言里所能写出来的最好的的代码了。如果你知道更多优雅的，请你一定告诉我！</p>
<p>好的，让我们来看一下使用效果。首先假设我们有两个需要修饰的函数：</p>
<pre class="brush: cpp; title: ; notranslate">func foo(a, b, c int) int {
        fmt.Printf(&quot;%d, %d, %d \n&quot;, a, b, c)
        return a + b + c
}

func bar(a, b string) string {
        fmt.Printf(&quot;%s, %s \n&quot;, a, b)
        return a + b
}</pre>

<p>然后，我们可以这样做：</p>
<pre class="brush: cpp; title: ; notranslate">
type MyFoo func(int, int, int) int
var myfoo MyFoo
Decorator(&amp;myfoo, foo)
myfoo(1, 2, 3)
</pre>

<p>你会发现，使用 <code>Decorator()</code> 时，还需要先声明一个函数签名，感觉好傻啊。一点都不泛型，不是吗？</p>
<p>嗯。如果你不想声明函数签名，那么你也可以这样</p>
<pre class="brush: cpp; title: ; notranslate">mybar := bar
Decorator(&amp;mybar, bar)
mybar(&quot;hello,&quot;, &quot;world!&quot;)</pre>

<p>好吧，看上去不是那么的漂亮，但是 it works。看样子 Go 语言目前本身的特性无法做成像 Java 或 Python 那样，对此，我们只能多求 Go 语言多放糖了！</p>
<p>Again， 如果你有更好的写法，请你一定要告诉我。</p>
<p>（全文完）</p>
<p><a href="https://cn.100offer.com/how-it-works/?utm_source=coolshell_cn&#038;utm_medium=display&#038;utm_campaign=coolshell_cn_20170615&#038;utm_content=find_new_job&#038;campaign_code=coolshell_cn target=_blank" target="_blank" rel="external"><img src="http://coolshell.cn/imgs/100offer_600_200.png" alt=""></a></p>
<p><img src="http://coolshell.cn//wp-content/uploads/2009/04/qrcode_for_gh_dd9d8c843f20_860-300x300.jpg" alt=""><br>关注CoolShell微信公众账号可以在手机端搜索文章</p>
<div style="margin-top: 15px; font-size: 11px;color: #cc0000;"><br><p align="center"><strong>（转载本站文章请注明作者和出处 <a href="http://coolshell.cn/" target="_blank" rel="external">酷 壳 &#8211; CoolShell</a> ，请勿用于任何商业用途）</strong></p></div><br><div style="text-align:center;padding:0px;font-size: 14px;margin-bottom: 50px;">——=== <strong>访问 <a href="http://coolshell.cn/404/ target=_blank" target="_blank" rel="external">酷壳404页面</a> 寻找遗失儿童。</strong> ===——</div>

<div class="wp_rp_wrap  wp_rp_vertical_m" id="wp_rp_first"><div class="wp_rp_content"><br><br>### 相关文章<br><br><em>   <a href="http://coolshell.cn/articles/11265.html" target="_blank" rel="external"><img src="http://coolshell.cn//wp-content/uploads/2014/03/snake-hat-new-year-schedule-800x960-150x150.jpg" alt="Python修饰器的函数式编程"></a><a href="http://coolshell.cn/articles/11265.html" target="_blank" rel="external">Python修饰器的函数式编程</a>
</em>   <a href="http://coolshell.cn/articles/8489.html" target="_blank" rel="external"><img src="http://coolshell.cn//wp-content/uploads/2012/11/google-go-language-150x150.jpg" alt="Go 语言简介（下）— 特性"></a><a href="http://coolshell.cn/articles/8489.html" target="_blank" rel="external">Go 语言简介（下）— 特性</a><br><em>   <a href="http://coolshell.cn/articles/8460.html" target="_blank" rel="external"><img src="http://coolshell.cn//wp-content/uploads/2012/11/go2-150x150.jpg" alt="Go 语言简介（上）— 语法"></a><a href="http://coolshell.cn/articles/8460.html" target="_blank" rel="external">Go 语言简介（上）— 语法</a>
</em>   <a href="http://coolshell.cn/articles/17524.html" target="_blank" rel="external"><img src="http://coolshell.cn//wp-content/uploads/2016/10/drawing-recursive-150x150.jpg" alt="如何读懂并写出装逼的函数式代码"></a><a href="http://coolshell.cn/articles/17524.html" target="_blank" rel="external">如何读懂并写出装逼的函数式代码</a><br><em>   <a href="http://coolshell.cn/articles/10822.html" target="_blank" rel="external"><img src="http://coolshell.cn//wp-content/uploads/2013/12/yoda-lambda-150x150.png" alt="函数式编程"></a><a href="http://coolshell.cn/articles/10822.html" target="_blank" rel="external">函数式编程</a>
</em>   <a href="http://coolshell.cn/articles/17757.html" target="_blank" rel="external"><img src="http://coolshell.cn//wp-content/uploads/2017/04/IMG_7411-150x150.jpg" alt="如何重构“箭头型”代码"></a><a href="http://coolshell.cn/articles/17757.html" target="_blank" rel="external">如何重构“箭头型”代码</a></div></div></section>
    
      <div class="tags">
        <span>Tags:</span>
        
  <span class="tag-code">程序设计</span>

  <span class="tag-code">Go 语言</span>

  <span class="tag-code">编程语言</span>

  <span class="tag-code">functional</span>

  <span class="tag-code">Go</span>

  <span class="tag-code">golang</span>

  <span class="tag-code">Programming</span>

  <span class="tag-code">函数式</span>

      </div>
    
    <div class="money-like">
      <div class="reward-btn">
        赏
        <span class="money-code">
          <span class="alipay-code">
            <div class="code-image"></div>
            <b>使用支付宝打赏</b>
          </span>
          <span class="wechat-code">
            <div class="code-image"></div>
            <b>使用微信打赏</b>
          </span>
        </span>
      </div>
      <p class="notice">若你觉得我的文章对你有帮助，欢迎点击上方按钮对我打赏</p>
    </div>
    <div class="qrcode">
      <canvas id="share-qrcode"></canvas>
      <p class="notice">扫描二维码，分享此文章</p>
    </div>
    <div id="comments"></div>
  </article>
</main>

<script>
  (function () {
    var url = 'http://blog.hhw.im/2017/06/01/Go语言的修饰器编程/';
    $('#article-banner').geopattern(url)
    $('.header').removeClass('fixed-header')

     // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png') 
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      var imageW = $(this).width()
      var imageH = $(this).height()
      
      var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
      zoom = zoom < 1 ? 1 : zoom
      zoom = zoom > 2 ? 2 : zoom
      var transY = (($(window).height() - imageH) / 2).toFixed(2)

      $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
      $('.image-view-wrap').addClass('wrap-active')
      $('.image-view-wrap img').css({
        'width': `${imageW}`,
        'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
      })
      $('html').css('overflow', 'hidden')

      $('.image-view-wrap').on('click', function() {
        $(this).remove()
        $('html').attr('style', '')
      })
    })

    // qrcode
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });

    // gitment
    var gitmentConfig = "hhw";
    if (gitmentConfig != "undefined") {
      var gitment = new Gitment({
        owner: "hhw",
        repo: "hhw.github.io",
        oauth: {
          client_id: "undefined",
          client_secret: "undefined"
        },
        theme: {
          render(state, instance) {
            const container = document.createElement('div')
            container.lang = "en-US"
            container.className = 'gitment-container gitment-root-container'
            container.appendChild(instance.renderHeader(state, instance))
            container.appendChild(instance.renderEditor(state, instance))
            container.appendChild(instance.renderComments(state, instance))
            container.appendChild(instance.renderFooter(state, instance))
            return container;
          }
        }
      })
      gitment.render(document.getElementById('comments'))
    }
  })();
</script>

    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2017 | H H W . I M
<!--Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a href="https://github.com/yanm1ng">yanm1ng</a>-->
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>
<script>
  var hasLine = 'true';
  async("//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine == 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->

<script src="/js/script.js"></script>

  </body>
</html>